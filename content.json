{"meta":{"title":"缺省的梦境","subtitle":"","description":"","author":"wizardTOT","url":"https://wizardtot.github.io","root":"/"},"pages":[{"title":"about","date":"2024-06-28T07:38:40.000Z","updated":"2025-01-18T04:48:34.786Z","comments":true,"path":"about/index.html","permalink":"https://wizardtot.github.io/about/index.html","excerpt":"","text":"普普通通的计科学生，欢迎恰Q161221879","author":"WizardTOT"},{"title":"所有分类","date":"2025-01-18T04:59:42.163Z","updated":"2025-01-18T04:59:42.163Z","comments":true,"path":"categories/index.html","permalink":"https://wizardtot.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-01-18T05:02:32.474Z","updated":"2025-01-18T05:02:32.474Z","comments":true,"path":"tags/index.html","permalink":"https://wizardtot.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"dp","date":"2025-03-08T12:35:51.233Z","updated":"2025-03-08T12:35:53.996Z","comments":true,"path":"2025/03/08/dp/","permalink":"https://wizardtot.github.io/2025/03/08/dp/","excerpt":"","text":"常规思路下最长公共子序列（LCS）的状态转移方程对于一般的最长公共子序列问题，设两个序列分别为 $A &#x3D; [a_1, a_2, \\cdots, a_m]$ 和 $B &#x3D; [b_1, b_2, \\cdots, b_n]$，定义 $dp[i][j]$ 表示 $A$ 的前 $i$ 个元素和 $B$ 的前 $j$ 个元素的最长公共子序列的长度。状态转移方程如下： 当 $a_i &#x3D; b_j$ 时，$dp[i][j] &#x3D; dp[i - 1][j - 1] + 1$。这是因为当当前两个元素相等时，它们可以作为公共子序列的一部分，所以最长公共子序列的长度在前一个状态的基础上加 1。 当 $a_i \\neq b_j$ 时，$dp[i][j] &#x3D; \\max(dp[i - 1][j], dp[i][j - 1])$。也就是说，此时最长公共子序列的长度取 $A$ 的前 $i - 1$ 个元素和 $B$ 的前 $j$ 个元素的最长公共子序列长度，以及 $A$ 的前 $i$ 个元素和 $B$ 的前 $j - 1$ 个元素的最长公共子序列长度中的较大值。 用代码实现上述思路的伪代码如下： 123456789# 初始化 dp 数组dp = [[0] * (n + 1) for _ in range(m + 1)]for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])# 最终结果为 dp[m][n] 但是这种方法的时间复杂度是 $O(mn)$，对于本题 $n \\leq 10^5$ 的数据范围会超时。 本题特殊情况的优化思路及状态转移方程本题中两个序列是 $1, 2, \\cdots, n$ 的排列，利用这个特殊性质可以将问题转化为最长上升子序列（LIS）问题。 设两个排列分别为 $P_1$ 和 $P_2$，我们构建一个映射数组 pos，pos[x] 表示 $x$ 在 $P_1$ 中的位置。然后对于 $P_2$ 中的每个元素 $x$，我们将其替换为 pos[x]，得到一个新的序列 $C$。那么 $P_1$ 和 $P_2$ 的最长公共子序列的长度就等于序列 $C$ 的最长上升子序列的长度。 对于最长上升子序列问题，设 $dp[i]$ 表示以第 $i$ 个元素结尾的最长上升子序列的长度，状态转移方程如下： $dp[i] &#x3D; \\max{dp[j] + 1 | j &lt; i, C[j] &lt; C[i]}$ 最终的最长上升子序列长度为 $\\max{dp[i] | 1 \\leq i \\leq n}$。 为了进一步优化时间复杂度，我们可以使用二分查找的方法来维护一个递增的数组 tail，tail[k] 表示长度为 $k + 1$ 的上升子序列的末尾元素的最小值。对于每个元素 $C[i]$，我们在 tail 中二分查找第一个大于等于 $C[i]$ 的位置 $pos$，如果 $pos$ 等于 tail 的长度，说明 $C[i]$ 比 tail 中的所有元素都大，我们可以将其添加到 tail 的末尾；否则，我们将 tail[pos] 更新为 $C[i]$。最终 tail 的长度就是最长上升子序列的长度。 以下是优化后的代码实现： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; P1(n + 1), P2(n + 1); vector&lt;int&gt; pos(n + 1); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; P1[i]; pos[P1[i]] = i; &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; P2[i]; &#125; vector&lt;int&gt; C; for (int i = 1; i &lt;= n; ++i) &#123; C.push_back(pos[P2[i]]); &#125; vector&lt;int&gt; tail; for (int num : C) &#123; auto it = lower_bound(tail.begin(), tail.end(), num); if (it == tail.end()) &#123; tail.push_back(num); &#125; else &#123; *it = num; &#125; &#125; cout &lt;&lt; tail.size() &lt;&lt; endl; return 0;&#125; 这种优化后的方法时间复杂度为 $O(n \\log n)$，可以通过本题的数据范围。","categories":[],"tags":[]},{"title":"西电操作系统实验攻略","slug":"西电操作系统实验攻略","date":"2025-01-18T05:08:11.000Z","updated":"2025-01-18T05:54:55.077Z","comments":true,"path":"2025/01/18/西电操作系统实验攻略/","permalink":"https://wizardtot.github.io/2025/01/18/%E8%A5%BF%E7%94%B5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%94%BB%E7%95%A5/","excerpt":"西电计科大二操作系统实验（非软工李航OS课设）","text":"西电计科大二操作系统实验（非软工李航OS课设） 计科的 OS 实验很水，意思意思前几个就行，用不着全部做完 实验报告实验题目一实验内容实验 1 创建进程 学会通过基本的 Windows 或者 Linux 进程控制函数，由父进程创建子进程，并实现父子进程协同工作。创建两个进程，让子进程读取一个文件，父进程等待子进程读取 完文件后继续执行，实现进程协同工作。 进程协同工作就是协调好两个进程，使之安排好先后次序并以此 执行，可以用等待函数来实现这一点。当需要等待子进程运行结束 时，可在父进程中调用等待函数。 代码本实验主要使用fork()系统调用，fork()一次调用，两次返回。当程序调用fork()时，它创建了一个新的子进程，这个子进程是当前调用fork()的父进程的副本。在子进程中，fork()返回0，而在父进程中，它返回新创建的子进程的进程PID。如果fork()调用失败，通常由于系统中没有足够的资源来创建新进程，它会返回一个负值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;int main() &#123; pid_t pid = fork(); if (pid &lt; 0) &#123; perror(&quot;fork&quot;); exit(pid); &#125; else if (pid == 0) &#123;//子进程 FILE *fp = fopen(&quot;./data.txt&quot;,&quot;w+&quot;); printf(&quot;Child process started: PID = %d\\n&quot;, getpid()); if(fp)&#123; const char *s1 = &quot;春江潮水连海平\\n&quot;; const char *s2 = &quot;海上明月共潮生\\n&quot;; fwrite(s1,strlen(s1),1,fp); fwrite(s2,strlen(s2),1,fp); &#125;else&#123; printf(&quot;child process failed to write data.\\n&quot;); &#125; fclose(fp); char content[200]; fp = fopen(&quot;./data.txt&quot;,&quot;r&quot;); fread(content, sizeof(char), 100, fp); std::cout &lt;&lt; &quot;child process writed data:\\n&quot; &lt;&lt; content; fclose(fp); &#125; else &#123;//父进程 printf(&quot;Parent process started: PID = %d\\n&quot;, getpid()); int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; sum = sum + i; printf(&quot;%d\\n&quot;,sum); &#125; std::cout &lt;&lt; &quot;Wait for child process...\\n&quot;; int status; waitpid(pid, &amp;status, 0);//等待子进程运行结束 std::cout &lt;&lt; &quot;Child process exited.\\n&quot;; FILE *fp = fopen(&quot;./data.txt&quot;, &quot;r&quot;); char content[200]; fread(content, sizeof(char), 100, fp); fclose(fp); std::cout &lt;&lt; &quot;Parent process read data:\\n&quot; &lt;&lt; content; std::cout &lt;&lt; &quot;Parent process exited.\\n&quot;; &#125; return 0;&#125; 运行结果图一是实验运行结果，图二是子进程写入文件中的内容，可以看到父进程成功实验fork()创建子进程，先打印运算1至50的累计和，然后等待子进程运行结束，子进程运行时向文件中写入“春江潮水连海平，海上明月共潮生”随后结束运行，父进程从文件中读取子进程写入的数据并打印，程序运行结束。 至于为什么没图片，你自己运行后截图吧.jpg 实验题目二实验内容实验 2 线程共享进程数据了解线程与进程之间的数据共享关系。创建一个线程，在线程中更改进程中的数据。在进程中定义全局共享数据，在线程中直接引用该数据进行更改并输出该数据。 代码本实验主要使用了POSIX线程库中的两个重要函数来创建和同步线程，pthread_create()和pthread_join()。pthread_create()函数原型如下： 12int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); phtread_create()用于创建一个新的线程，thread: 指向 pthread_t 类型变量的指针，该变量用于唯一标识新创建的线程。attr: 指向线程属性对象的指针。可以指定线程属性，如堆栈大小、调度策略等。start_routine: 新线程将执行的函数的指针，arg: 传递给 start_routine 函数的参数。在本实验中，创建threadProc()函数传入pthread_create()用于新线程执行，当线程创建成功时，pthread_create ()返回 0，如果失败，则返回错误码。pthread_join()用于等待指定的线程终止，函数原型如下： 1int pthread_join(pthread_t thread, void **retval); thread: 要等待的线程的标识符，该线程应该是由 pthread_create ()创建的。retval: 如果不是 NULL，则指向的位置会被设置为被等待线程的返回值。当成功等待线程终止时，pthread_join 返回 0,如果失败，则返回错误码。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;iostream&gt;using namespace std;static int count;void *threadProc(void *arg) &#123; cout &lt;&lt; &quot;new thread started.\\n&quot;; for (count = 1; count &lt;= 10; count += 2) &#123; cout &lt;&lt; &quot;now: count =&quot; &lt;&lt; count &lt;&lt; &quot;\\n&quot;; &#125; cout &lt;&lt; &quot;wait for 3 seconds...\\n&quot;; sleep(3); return 0;&#125;int main() &#123; count = 20; std::cout &lt;&lt;&quot;Main process started!\\n&quot; &lt;&lt; &quot;count = &quot; &lt;&lt; count &lt;&lt; endl; pthread_t tid; unsigned int t = pthread_create(&amp;tid, NULL, threadProc, NULL); if (t) &#123; perror(&quot;pthread_create&quot;); exit(t); &#125; void *retraval = NULL; if (pthread_join(tid, &amp;retraval) != 0) &#123; perror(&quot;thread&quot;); &#125; std::cout &lt;&lt; &quot;Thread ended.\\n&quot;; std::cout &lt;&lt; &quot;Main process ended.\\n&quot; &lt;&lt; &quot;count = &quot; &lt;&lt; count &lt;&lt; endl; return 0;&#125; 运行结果在实验结果中可以看到新线程成功创建并运行，并且静态全局变量count是并发访问的，在线程运行时，count值改变并影响到主进程，最后结束时count值为11而非初始设定的20。 实验题目三实验内容利用信号通信机制在父子进程及兄弟进程间进行通信。父进程创建一个有名事件，由子进程发送事件信号，父进程获取事件信号后进行相应的处理。 代码本实验主要使用POSIX有名信号量在父子进程之间实现通信，本实验通过fork()创建子进程，父进程注册了 SIGUSR1 信号的处理函数 handle_sigusr1，在子进程中会提示用户是否要向父进程发送 SIGUSR1 信号，当接收到这个信号时，会调用这个函数。 父进程在创建信号量后会调用 sem_timedwait（），在指定的时间内等待信号量的值增加。如果在 10 秒内信号量的值被增加（即子进程发送了信号并且信号处理函数被调用），父进程会继续执行并打印一条消息表示信号量已经被处理。如果 10 秒内没有收到信号，sem_timedwait 会因超时而返回，并打印一条超时消息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;semaphore.h&gt;#include &lt;iostream&gt;#define SEM_NAME &quot;/my_named_event&quot;// 信号处理函数void handle_sigusr1(int sig) &#123; sem_t *sem = sem_open(SEM_NAME, 0); if (sem != SEM_FAILED) &#123; printf(&quot;Received SIGUSR1, handling the named event...\\n&quot;); sem_post(sem); // 触发事件 sem_close(sem); &#125;&#125;int main() &#123; pid_t pid; // 创建子进程 pid = fork(); if (pid &lt; 0) &#123; perror(&quot;fork&quot;); exit(-1); &#125; if (pid == 0) &#123; // 子进程 sleep(3); printf(&quot;Child process started.\\n&quot;); char ch; std::cout &lt;&lt; &quot;Signal the event to Parent[y/n]\\n&quot;; std::cin &gt;&gt; ch; if (ch == &#x27;y&#x27;) &#123; kill(getppid(), SIGUSR1); // 向父进程发送SIGUSR1信号 &#125; exit(0); &#125; else&#123; // 父进程 std::cout &lt;&lt; &quot;Parent process started.\\n&quot;; // 创建有名事件 sem_t *sem; sem = sem_open(SEM_NAME, O_CREAT, 0644, 0); if (sem == SEM_FAILED) &#123; perror(&quot;sem_open&quot;); exit(EXIT_FAILURE); &#125; signal(SIGUSR1, handle_sigusr1); // 设置定时等待事件 struct timespec ts; if (clock_gettime(CLOCK_REALTIME, &amp;ts) == -1) &#123; perror(&quot;clock_gettime&quot;); exit(EXIT_FAILURE); &#125; ts.tv_sec += 10; int ret; while ((ret = sem_timedwait(sem, &amp;ts)) == -1 &amp;&amp; errno == EINTR) &#123; continue; &#125; if (ret == -1) &#123; if (errno == ETIMEDOUT) &#123; printf(&quot;timed out.\\n&quot;); &#125; exit(-1); &#125;else&#123; std::cout &lt;&lt; &quot;Named event handled in parent process.\\n&quot;; &#125; sem_close(sem); sem_unlink(SEM_NAME); &#125; return 0;&#125; 运行结果第一次运行时，在子进程中没有发送SIGUSR1 信号，父进程等待超时结束运行，在第二次运行时，子进程发送SIGUSR1 ，信号处理函数被调用，父进程收到信号打印Named event handled in parent process.。 实验题目四实验内容实验题目 匿名管道通信 学习使用匿名管道在两个进程间建立通信。 分别建立名为 Parent 的单文档应用程序和 Child 的单文档应用程 序作为父子进程，由父进程创建一个匿名管道，实现父子进程向匿 名管道写入和读取数据。 代码本次实验主要使用fork()创建子进程，使用 pipe() 函数创建匿名管道。这个函数需要一个包含两个整数的数组作为参数，成功调用后，这个数组的两个元素会被设置为管道的读端和写端的文件描述符。例如创建fd[2]数组，使用pipe()创建管道后，fd[0] 用于读取管道，fd[1] 用于写入管道。 管道是单向的，数据只能沿一个方向流动，对于父子进程之间双向通信，就必须创建两个管道。close()用于关闭管道，write()用于向管道中写入数据，read()用于向管道中读数据。在向管道写入数据时，要使用close(fd[0])关闭管道读端，在向管道中读取数据时，要使用close(fd[1])关闭管道写端。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;const int BUF_SIZE = 100;int main()&#123; int fd1[2]; if (pipe(fd1) == -1 )//创建子进程读，父进程写管道 &#123; perror(&quot;Fail to create pipe.\\n&quot;); exit(-1); &#125; int fd2[2]; if(pipe(fd2) == -1)&#123;//创建父进程读，子进程写管道 perror(&quot;Fail to create pipe.\\n&quot;); exit(-1); &#125; pid_t pid = fork();//创建进程 if(pid&lt;0)&#123; perror(&quot;Fail to fork.&quot;); exit(pid); &#125; else if(pid ==0)&#123;//子进程 FILE *fp; fp = fopen(&quot;child4.txt&quot;,&quot;w&quot;); char str[] = &quot;--------Child process started.--------\\n&quot;; fwrite(str,strlen(str),1,fp); close(fd1[1]); char message_receive2[BUF_SIZE]; read(fd1[0], message_receive2, BUF_SIZE);//子进程读数据 close(fd1[0]); strcpy(str,&quot;Child process read data from pipe:&quot;); fwrite(str,strlen(str),1,fp); fwrite(message_receive2,strlen(message_receive2),1,fp); char message_to_send2[BUF_SIZE] = &quot;Hello Manchester!\\n&quot;; close(fd2[0]); write(fd2[1],message_to_send2,sizeof(message_to_send2));//子进程写数据 close(fd2[1]); strcpy(str,&quot;Child process writed data in pipe:&quot;); fwrite(str,strlen(str),1,fp); fwrite(message_to_send2,strlen(message_to_send2),1,fp); strcpy(str,&quot;--------Child process exited.--------\\n&quot;); fwrite(str,strlen(str),1,fp); fclose(fp); &#125; else&#123;//父进程 printf(&quot;***Parent process started.***\\n&quot;); close(fd1[0]); char message_to_send1[BUF_SIZE] = &quot;Hala Madrid!\\n&quot;; write(fd1[1], message_to_send1,sizeof(message_to_send1));//父进程写数据 printf(&quot;Parent process writed data in pipe: %s&quot;, message_to_send1); close(fd1[1]); char message_to_receive1[BUF_SIZE]; close(fd2[1]); read(fd2[0],message_to_receive1,BUF_SIZE);//父进程读数据 printf(&quot;Parent process read data from pipe: %s&quot;,message_to_receive1); close(fd2[0]); printf(&quot;***Parent process exited.***\\n&quot;); &#125; exit(0);&#125; 运行结果实验结果可以看出，匿名管道成功创建，实现父子进程之间的通信，父进程向管道中写入Hala Madrid!并被子进程成功读取，子进程向管道中写入Hello Manchester!并被父进程成功读取。 实验题目五实验内容实验 5 命名管道通信 学习使用命名管道在多进程间建立通信。建立父子进程，由父进程创建一个命名管道，由子进程向命名管道写入数据，由父进程从命名管道读取数据。 代码在本实验中，使用fork()创建子进程，使用mkfifo() 创建有名管道，mkfifo() 是一个在 UNIX系统上用于创建有名管道（FIFO）的系统调用。有名管道是一种特殊类型的文件，它允许两个或多个进程实现进程间通信，一旦创建了 FIFO，进程就可以像普通文件一样打开它进行读写操作。一个进程可以写入数据到管道的一端，而另一个进程则可以从管道的另一端读取数据。 FIFO 在文件系统中持久存在，它不像匿名管道那样在进程终止时自动消失，在使用完后要使用unlink()显式删除。 父进程功能：进入循环，先使用open(FIFO_PATH, O_RDONLY)以只读打开 FIFO 以进行读取。调用read(fd, message, BUF_SIZE)从 FIFO 中读取数据到message中，读取后使用close()关闭管道，如果读取到的数据是 “end”，则退出循环，如果读取到的数据不是 “end”，则使用open(FIFO_PATH, O_WRONLY)只写方式打开FIFO，提示用户输入要发送给子进程的数据，并使用write()此数据写入 FIFO。 子进程功能：进入循环，先使用open(FIFO_PATH, O_WRONLY)以只写方式打开 FIFO,提示用户输入要发送给父进程的数据, 使用write()此数据写入 FIFO。写入后使用close()关闭管道，如果写入的数据是 “end”，则退出循环。再使用使用open(FIFO_PATH, O_RDONLY)以只读打开 FIFO，用read()读取父进程发送的数据并打印。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;iostream&gt;using namespace std;#define FIFO_PATH &quot;./lab5_FIFO&quot;const int BUF_SIZE = 100;int main()&#123; if (mkfifo(FIFO_PATH, 0600) == -1) &#123;//创建有名管道 perror(&quot;mkfifo&quot;); exit(-1); &#125; pid_t pid = fork(); if(pid&lt;0)&#123; perror(&quot;fork&quot;); exit(pid); &#125;else if(pid &gt; 0)&#123;//父进程 printf(&quot;Parent process started: PID = %u\\n&quot;, getpid()); while (1) &#123; int fd = open(FIFO_PATH, O_RDONLY); char message[BUF_SIZE]; if(read(fd, message, BUF_SIZE)&gt;0)&#123;//父进程从管道中读 cout &lt;&lt;&quot;Parent process read from fifo:&quot; &lt;&lt; message &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;Parent process failed to read.\\n&quot;; exit(-1); &#125; close(fd); if(strcmp(message,&quot;end&quot;)==0)&#123; unlink(FIFO_PATH);//拆除有名管道 cout &lt;&lt; &quot;FIFO is deleted.\\n&quot;; cout &lt;&lt; &quot;Parent process exited.\\n&quot;; exit(0); &#125; fd = open(FIFO_PATH, O_WRONLY); cout &lt;&lt; &quot;Please enter data sent to child process:&quot;; cin &gt;&gt; message; if(write(fd,message,strlen(message)+1)&gt;0)&#123;//父进程从管道中写 cout &lt;&lt; &quot;Parent process successed to write data.\\n&quot;; &#125;else&#123; cout &lt;&lt; &quot;Parent process failed to write data.\\n&quot;; exit(-1); &#125; close(fd); &#125; &#125; else&#123;//子进程 printf(&quot;Child process started. PID = %u\\n&quot;, getpid()); while (1) &#123; int fd = open(FIFO_PATH, O_WRONLY); char message2[BUF_SIZE]; cout &lt;&lt; &quot;Please enter data sent to parent process:&quot;; cin &gt;&gt; message2; if(write(fd, message2, strlen(message2) + 1)&gt;0)&#123;//子进程向管道中写 cout &lt;&lt; &quot;Child process successed to write data.\\n&quot;; &#125;else&#123; cout &lt;&lt; &quot;Child process failed to write data.\\n&quot;; exit(-1); &#125; close(fd); if(strcmp(message2,&quot;end&quot;)==0)&#123; break; &#125; fd = open(FIFO_PATH, O_RDONLY); if(read(fd, message2, BUF_SIZE)&gt;0)&#123;//子进程从管道中读 cout &lt;&lt;&quot;Child process read from fifo:&quot; &lt;&lt; message2&lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;Child process failed to read.\\n&quot;; exit(-1); &#125; close(fd); &#125; printf(&quot;Child process exited.\\n&quot;); &#125;&#125; 运行结果从实验结果可以看到，FIFO成功创建，子进程写入向FIFO中child，父进程成功读取，父进程写入parent，子进程成功读取，子进程写入end时，父子进程结束运行，FIFO删除。 实验题目六实验题目 信号量实现进程同步 进程同步是操作系统多进程&#x2F;多线程并发执行的关键之一，进程 同步是并发进程为了完成共同任务采用某个条件来协调他们的活 动，这是进程之间发生的一种直接制约关系。本次试验是利用信号 量进行进程同步。 生产者进程生产产品，消费者进程消费产品。 当生产者进程生产产品时，如果没有空缓冲区可用，那么生产 者进程必须等待消费者进程释放出一个缓冲区。 当消费者进程消费产品时，如果缓冲区中没有产品，那么消费 者进程将被阻塞，直到新的产品被生产出来。 实验内容本实验使用POSIX 线程库中的pthread_create()创建新线程，使用POSIX信号量实现线程间的同步和互斥模拟生产者和消费者问题，实验初始化了三个信号量 —— mutex 用于互斥访问缓冲区，保证每次只有一个线程可以操作缓冲区；empty 表示缓冲区中空闲位置的数量，初始值为缓冲区大小（BUF_SIZE）；full 表示缓冲区中已填充数据的位置数量，初始值为 0，使用sem_init()对信号量进行初始化，sem_wait()对应P操作，sem_post()对应V操作，信号量使用完后要使用sem_destory()对信号量进行销毁。 生产者线程每2秒生产一个产品，然后尝试将其放入缓冲区。它首先需要等待 empty 信号量（确保缓冲区有空位），然后获取 mutex 信号量（确保互斥访问缓冲区），将产品放入缓冲区，然后释放 mutex 并增加 full 信号量。 消费者线程A和B分别在启动后等待 5 秒和 10 秒，然后开始消费缓冲区中的产品。首先等待 full 信号量（确保缓冲区中有数据），然后获取 mutex 信号量（确保互斥访问缓冲区），从缓冲区取出一个产品，然后释放 mutex 并增加 empty 信号量。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;semaphore.h&gt;#include &lt;pthread.h&gt;#include &lt;stdbool.h&gt;const int BUF_SIZE = 10;int buf[BUF_SIZE];int buf_pointer;sem_t mutex,empty,full;void *Producer(void *arg)&#123; //生产者 int product = 0; printf(&quot;Producer started.\\n&quot;); while(true)&#123; sleep(2); sem_wait(&amp;empty); sem_wait(&amp;mutex); printf(&quot;Producer gets mutex.\\n&quot;); buf[buf_pointer++] = product; printf(&quot;Producer produced: %d\\n&quot;,product); product ++; printf(&quot;Producer releases mutex.\\n&quot;); sem_post(&amp;mutex); sem_post(&amp;full); &#125;&#125;void *Consumer_A(void *arg)&#123;//消费者A sleep(5); printf(&quot;Consumer_A started.\\n&quot;); while(true)&#123; sem_wait(&amp;full); sem_wait(&amp;mutex); printf(&quot;Consumer_A gets the mutex.\\n&quot;); int product_ = buf[--buf_pointer]; printf(&quot;Consumer_A consumed: %d\\n&quot;,product_); printf(&quot;Consumer_A releases mutex.\\n&quot;); sem_post(&amp;mutex); sem_post(&amp;empty); sleep(1); &#125;&#125;void *Consumer_B(void *arg)&#123;//消费者B sleep(10); printf(&quot;Consumer_B started.\\n&quot;); while(true)&#123; sem_wait(&amp;full); sem_wait(&amp;mutex); printf(&quot;Consumer_B gets the mutex.\\n&quot;); int product_ = buf[--buf_pointer]; printf(&quot;Consumer_B consumed: %d\\n&quot;,product_); printf(&quot;Consumer_B releases mutex.\\n&quot;); sem_post(&amp;mutex); sem_post(&amp;empty); sleep(2); &#125;&#125;int main()&#123; sem_init(&amp;mutex, 0, 1);//初始化信号量 sem_init(&amp;empty, 0, 10); sem_init(&amp;full, 0, 0); pthread_t producer_thread,consumerA_thread,consumerB_thread;//创建线程 pthread_create(&amp;producer_thread, NULL, Producer, NULL); pthread_create(&amp;consumerA_thread, NULL, Consumer_A, NULL); pthread_create(&amp;consumerB_thread, NULL, Consumer_B, NULL); int flag = 1;//终止运行 while (flag) &#123; if(getchar())&#123; flag = 0; &#125; &#125; sem_destroy(&amp;mutex); sem_destroy(&amp;empty); sem_destroy(&amp;full); exit(0);&#125; 运行结果从实验结果可以看出，生产者和消费者线程成功创建并运行，互斥进入临界缓存，生产者生产产品后消费者进行消费，生产者也与消费者之间实现同步，键入-1时程序结束运行。 实验题目七实验内容实验题目 共享主存实现进程通信 利用共享主存解决读写者问题。要求写者进程创建一个共享主 存，并向其中写入数据，读者进程随后从该共享主存区中访问数据。 为基于共享主存解决读者-写者问题，需要由写进程首先创建一 个共享主存，并将该共享主存区映射到虚拟地址空间，随后读进程打开共享主存，并将该共享主存区映射到自己的虚拟地址空间，从 中获取数据，并进行处理，以此实现进程通信。 实验代码本次实验使用fork()创建子进程运行，父进程是写者进程，子进程是读者进程，使用POSIX有名信号量实现进程间同步，使用 sem_open() 创建两个信号量 db 和 writeMutex。db 用于控制对共享内存的访问，而 writeMutex 用于保护写者的优先权, 为方便运行，本次实验将信号量通信机制封装在start_write(),end_write(),start_read(),end_read()函数中。 对于创建共享内存，通过 ftok()生成一个键值，然后使用 shmget ()获取共享内存标识符，创建一个新的共享内存段或访问一个已存在的共享内存段， shmat ()将共享内存映射到进程的地址空间, shmdt()将共享内存段从进程的地址空间分离。 程序执行时，父进程（写者）和子进程（读者）都会启动。父进程将从用户那里读取整数并将它们写入共享内存，子进程将等待并读取这些整数。由于使用了 writeMutex 信号量，写操作将始终优先于读操作。这意味着如果写者和读者同时尝试访问共享内存，写者将获得优先权。只有在写者完成写操作并释放了信号量后，读者才能开始读操作。这可以防止读者在写者完成写入之前读取不完整或旧的数据。父进程在写入 -1 到共享内存后结束，然后等待子进程结束。子进程在读取到 -1 后结束。之后，父进程清理了创建的信号量和共享内存段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;sys/shm.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;semaphore.h&gt;#define SHM_SIZE 1024using namespace std;sem_t *db; // 控制对共享内存的访问sem_t *writeMutex; // 保护写者的优先权void start_write() &#123; sem_wait(writeMutex); // 确保写者优先 sem_wait(db); &#125;void end_write() &#123; sem_post(db); sem_post(writeMutex); // 允许读者或写者进入&#125;void start_read() &#123; sem_wait(writeMutex); // 确保写者优先 sem_wait(db); &#125;void end_read() &#123; sem_post(db); sem_post(writeMutex); &#125;int get_shmid()&#123; int key = ftok(&quot;./&quot;, 9); //生成键值 if(key == -1) &#123; perror(&quot;ftok&quot;); &#125; int shm_id = shmget(key, SHM_SIZE, IPC_CREAT|0644);//获取共享内存标识符 if(shm_id &lt; 0) &#123; perror(&quot;shmget&quot;); exit(-1); &#125; return shm_id; &#125;int *create_shm()&#123; int shm_id = get_shmid(); int *shm_add = (int *)shmat(shm_id, NULL, 0);//映射共享内存段 if(shm_add &lt; (int *)0) &#123; perror(&quot;shmat&quot;); exit(-1); &#125; return shm_add;&#125;void del_shm()&#123; int shm_id = get_shmid(); shmctl(shm_id, IPC_RMID, NULL);&#125;int main() &#123; // 初始化信号量 sem_unlink(&quot;db_&quot;); sem_unlink(&quot;writeMutex_&quot;); db = sem_open(&quot;db_&quot;, O_CREAT, 0644, 1); writeMutex = sem_open(&quot;writeMutex_&quot;, O_CREAT, 0644, 1); pid_t pid = fork(); if (pid &lt; 0) &#123; perror(&quot;fork&quot;); exit(-1); &#125; else if (pid &gt; 0) &#123; // 父进程 - 写者 cout &lt;&lt; &quot;Writer process started.\\n&quot;; int *shm_add = create_shm(); int a = 1; while (1) &#123; start_write(); cout &lt;&lt; &quot;Writer process writed:\\n&quot;; int t; cin &gt;&gt; t; shm_add[0] = a; shm_add[a++] = t; end_write(); if(t == -1)&#123; shmdt(shm_add); break; &#125; sleep(3); &#125; wait(NULL); // 等待子进程结束 // 清理信号量 sem_close(db); sem_close(writeMutex); sem_unlink(&quot;db_&quot;); sem_unlink(&quot;writeMutex_&quot;); del_shm(); cout &lt;&lt; &quot;Writer process ended.\\n&quot;; &#125; else &#123;//子进程—读者进程 cout &lt;&lt; &quot;Reader process started.\\n&quot;; int *shm_add = create_shm(); while (1) &#123; start_read(); cout &lt;&lt; &quot;Reader process read:&quot;; for(int i =1;i&lt;=shm_add[0];i++)&#123; cout &lt;&lt; shm_add[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; if(shm_add[shm_add[0]] == -1)&#123; break; &#125; end_read(); sleep(1); &#125; // 清理信号量 sem_close(db); sem_close(writeMutex); cout &lt;&lt; &quot;Reader process ended.\\n&quot;; &#125; return 0;&#125; 运行结果从实验结果中可以看出读者写者进程成功通过共享内存实现进程间通信，写者写入的数据能正确被读者读出，通过有名信号量实现了读者写者对共享内存的同步，并在写者写入-1时，读者写者进程运行结束。 实验题目九实验题目： 通过内核模式显示进程控制块信息 了解 Linux 内核模块变成，熟悉 Linux 内核机制。在内核中，所有的进程控制块都被一个双向链表连接起来， 该链表中的第一个进程控制块为 init_task。编写一个内核模块，模 块接收用户传递的一个参数 num， num 指定要打印的进程控制块的 数量；若用户不指定 num 或者 num&lt;0，模块则打印所有进程控制块的信息，需要打印的进程控制块信息由：进程 PID 和进程的可执行文件名组成。 实验内容实验首先定义静态全局变量 num，默认值为 -1，未指定num值时默认打印所有进程的信息。module_param(num, int, 0644)允许在加载模块时指定一个值，0644 表示权限位（用户可读写，组和其他用户可读）。 随后是模块初始化函数 list_tasks_init(), 这是模块加载时调用的初始化函数。它使用 for_each_process(task) 宏迭代系统中的所有进程，并打印它们的 PID 和命令名（task-&gt;comm）。如果用户指定了 num 参数且不为 -1，则只打印指定数量的进程信息。如果 num 为 -1 或未指定，打印所有进程的信息。 list_tasks_exit()是模块卸载时调用的清理函数。简单地打印“Unloaded module”到内核日志。 MODULE_LICENSE(“GPL”); 指定了模块的许可证，这里是 GNU General Public License。MODULE_AUTHOR 和 MODULE_DESCRIPTION 宏分别提供了模块的作者信息和描述。 编写makefile，生成后使用insmod来加载lab.ko内核模块，使用dmesg即可查看进程的pid和命令名。 实验代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/sched/signal.h&gt;#include &lt;linux/moduleparam.h&gt;static int num = -1;module_param(num, int, 0644);MODULE_PARM_DESC(num, &quot;Number of process control blocks to print&quot;);static int __init list_tasks_init(void)&#123; struct task_struct *task; int count = 0; for_each_process(task) &#123; if (num &gt;= 0 &amp;&amp; count &gt;= num) break; printk(KERN_INFO &quot;PID: %d | Command: %s\\n&quot;, task-&gt;pid, task-&gt;comm); count++; &#125; if (num &lt; 0) printk(KERN_INFO &quot;Printed all process control blocks\\n&quot;); else printk(KERN_INFO &quot;Printed %d process control blocks\\n&quot;, count); return 0;&#125;static void __exit list_tasks_exit(void)&#123; printk(KERN_INFO &quot;Unloaded module\\n&quot;);&#125;module_init(list_tasks_init);module_exit(list_tasks_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;Wizard&quot;);MODULE_DESCRIPTION(&quot;A module to list process control blocks&quot;); 运行结果在实验结果中可以看到内核模块顺利载入，未指定num值执行dmesg后打印所有进程的pid和命令名，载入内核模块时指定num&#x3D;5后执行dmesg后打印5个进程的pid和命令名。","categories":[{"name":"实验","slug":"实验","permalink":"https://wizardtot.github.io/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"实验","slug":"实验","permalink":"https://wizardtot.github.io/tags/%E5%AE%9E%E9%AA%8C/"}],"author":"WizardTOT"},{"title":"西电计组实验攻略","slug":"西电计组实验攻略","date":"2024-06-29T13:08:34.000Z","updated":"2025-01-18T05:08:53.744Z","comments":true,"path":"2024/06/29/西电计组实验攻略/","permalink":"https://wizardtot.github.io/2024/06/29/%E8%A5%BF%E7%94%B5%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C%E6%94%BB%E7%95%A5/","excerpt":"西电计科大二计算机组成与体系结构实验","text":"西电计科大二计算机组成与体系结构实验 关于实验大二下学期鄙人确实被计科的实验安排恶心到了。这些实验不难，但非常占用时间，学期末实验成绩也不错，为了造福以后的学妹学弟，特此将实验报告放底下，可以参考参考，但是不要直接抄袭。 实验攻略其实每个实验老师都还行，没有对策府库那么夸张。老师之间的要求有些不同，我的老师每次实验都会提出一些创新的要求，完成要求可以获得A或者A+，没有完成要求只能获得A-，但是如果直接使用demo会喜提B，也听说有做得快就能得高分的老师。 快速完成实验可以直接打开D盘找到前几批的遗产。 实验报告实验一 存储器实验【实验目的】 掌握 FPGA 中 lpm_ROM 的设置，作为只读存储器 ROM 的工作特性和配置方法。用文本编辑器编辑 mif 文件配置 ROM，学习将程序代码以 mif 格式文件加载于lpm_ROM 中；在初始化存储器编辑窗口编辑 mif 文件配置 ROM；验证 FPGA 中 mega_lpm_ROM 的功能。 【实验环境】 QuartusII、FPGA实验箱 【实验基本原理及步骤】 lpm_ROM 有 5 组信号：地址信号 address[ ]、数据信号 q[ ]、时钟信号 inclock、outclock、允许信号memenable，其参数都是可以设定的。由于 ROM 是只读存储器，所以它的数据口是单向的输出端口，ROM 中的数据是在对 FPGA 现场配置时，通过配置文件一起写入存储单元的。图 3-1-1 中的 lpm_ROM 有 3 组信号：inclk——输入时钟脉冲；q[23..0]——lpm_ROM 的 24 位数据输出端；a[5..0]——lpm_ROM 的 6 位读出地址。实验中主要掌握以下三方面的内容： lpm_ROM 的参数设置； lpm_ROM 中数据的写入，即 LPM_FILE 初始化文件的编写； lpm_ROM 的实际应用，在实验台上的调试方法。 实验原理图： 实验步骤如下： 用图形编辑，进入mega_lpm元件库，调用lpm_rom元件，设置地址总线宽度address[]和数据总线宽度q[]，分别为6位和8位,并添加输入输出引脚，如图设置和连接。 设置上图为工程。 在设置lpm_rom数据参数选择项lpm_file的对应窗口中，用键盘输入lpm_ROM配置文件的路径（rom_a.mif），然后设置在系统ROM&#x2F;RAM读写允许，以便能对FPGA中的ROM在系统读写。 用初始化存储器编辑窗口编辑lpm_ROM配置文件（文件名.mif）。这里预先给出后面将要用到的微程序文件：rom_a.mif 。rom_a.mif中的数据是微指令码。 全程编译。 下载SOF文件至FPGA，改变lpm_ROM的地址a[5..0]，外加读脉冲，通过实验台上的数码管比较读出的数据是否与初始化数据(rom_a.mif中的数据)一致。 【实验数据记录】 仿真波形图：设定的ROM数据如下： 【实验结果分析】 在波形仿真中可以看到设定的地址信号address是随着时钟周期顺序增加的，lpm_ROM对应地址存储的数据被相应读出。 将sof文件下载到FPGA实验箱后，改变ROM的地址a[5..0]，外加读脉冲，通过观察数码管的显示可以发现与mif文件设置的数据一致，本次实验验证了lpm_rom作为只读储存器，数据要一次性写入到rom中，在读取数据时要通过输入指定的地址值并在时钟信号的驱动下，lpm_rom会将输出地址对应的数据。 通过本次实验我对lpm_rom有了深入的理解，FPGA中lpm_rom由EBA构成，存储内容在配置的过程中写入的，一旦配置完成内容就固定，只能读取不能修改，这种只读特性使得lpm_rom适用于在计算机中存储固定数据和固件等需要保持不变的信息。 实验二 运算器实验【实验目的】 了解简单运算器的数据传输通路。验证运算功能发生器的组合功能。 掌握算术逻辑运算加、减、与的工作原理。验证实验台运算的 8 位加、减、与、直通功能。按给定数据，完成几种指定的算术和逻辑运算。 【实验环境】 QuartusII、FPGA实验箱 【实验基本原理及步骤】 算术逻辑单元 ALU 的数据通路如图 2-1 所示。其中运算器 ALU181 根据 74LS181 的功能用 VHDL 硬件描述语言编辑而成，构成 8 位字长的 ALU。参加运算的两个 8 位数据分别为 A[7..0]和 B[7..0]，运算模式由 S[3..0]的 16 种组合决定，而 S[3..0]的值由4 位 2 进制计数器 LPM_COUNTER 产生，计数时钟是 Sclk（图 2-1）；此外，设 M&#x3D;0，选择算术运算，M&#x3D;1 为逻辑运算，CN为低位的进位位；F[7..0]为输出结果，CO为运算后的输出进位位。两个 8 位数据由总线 IN[7..0]分别通过两个电平锁存器 74373 锁入。 实验步骤如下： 设计ALU元件在Quartus II 环境下，用文本输入编辑器Text Editor输入ALU181.VHD算术逻辑单元文件，编译VHDL文件，并将ALU181.VHD文件制作成一个可调用的原理图元件。 以原理图方式建立顶层文件工程选择图形方式。根据图2-1输入实验电路图，从Quartus II的基本元件库中将各元件调入图形编辑窗口、连线，添加输入输出引脚。将所设计的图形文件ALU.bdf保存到原先建立的文件夹中，将当前文件设置成工程文件，以后的操作就都是对当前工程文件进行的。 器件选择选择Cyclone系列，在Devices中选择器件EP1C6QC240C8。编译，引脚锁定，再编译。引脚锁定后需要再次进行编译，才能将锁定信息确定下来，同时生成芯片编程&#x2F;配置所需要的各种文件。 芯片编程Programming（可以直接选择光盘中的示例已完成的设计进行验证实验）打开编程窗口。将配置文件ALU.sof下载进GW48系列现代计算机组成原理系统中的FPGA中。 选择实验系统的电路模式是NO.0，验证ALU的运算器的算术运算和逻辑运算功能根据表2-1，从键盘输入数据A[7..0]和B[7..0]，并设置S[3..0]、M、Cy，验证ALU运算器的算术运算和逻辑运算功能，记录实验数据。 【实验数据记录】 电路设计图如下：仿真波形图如下：ALU181.VHL如下：【实验结果分析】 图一是本次实验的原理图，其中ALU181是运算器，是通过编译VHDL文件生成的原理图文件，74343B是8位的缓存器，用于暂存向ALU中输入的数据，A0_B1信号控制数据送入到哪个暂存器中，低电平送入到A暂存器中，高电平送入到B暂存器中，S信号控制ALU的运算模式（对应实验原理中的表格），M信号用于控制ALU执行算术运算还是逻辑运算，ALU的运算结果为F，在波形图中，输入到暂存器A的数据为AA，输入到暂存器B的数据为55，执行算术运算，对应的运算结果与ALU的运算模式一致，在FPGA实验箱中运算结果也一致。 通过本次实验我对CPU中的ALU部件有了更清晰的认知，ALU可执行多种算术运算和逻辑运算，ALU的工作流程是由控制单元控制的，接收来自寄存器中的数据，根据对应的控制信号执行特定的运算类型，ALU通过与其他部件协调工作，实现了计算机内部的高效运算和处理能力。 实验三 节拍脉冲发生器时序电路实验【实验目的】 掌握节拍脉冲发生器的设计方法和工作原理。 理解节拍脉冲发生器的工作原理。 【实验环境】 QuartusII、FPGA实验箱 【实验基本原理及步骤】 计算机之所以能够按照人们事先规定的顺序进行一系列的操作或运算，就是因为它的控制部分能够按一定的先后顺序正确地发出一系列相应的控制信号。这就要求计算机必须有时序电路。控制信号就是根据时序信号产生的。本实验说明时序电路中节拍脉冲发生器的工作原理。连续节拍发生电路：可由 4 个 D 触发器组成，可产生 4 个等间隔的时序信号 T1T4，其中 CLK1 为时钟信号，由实验台右边的方波信号源 clock0 提供，可产生 1Hz12MHz 的方波信号频率。实验者可根据实验自行选择信号频率。当 RST1 为低电平时，T1 输出为“1”，而 T2、T3、T4 输出为“0”；当 RST1 由低电平变为高电平后，T1~T4 将在CLK1 的输入脉冲作用下，周期性地轮流输出正脉冲，机器进入连续运行状态（EXEC）。单步节拍发生电路：该电路每当 RST1 出现一个负脉冲后，仅输出一组 T1、T2、T3、T4 节拍信号，直到 RST1 出现下一个负脉冲单步&#x2F;连续节拍发生电路:增加两个 2-1 多路选择器，可将图单步节拍发生电路改变为单步&#x2F;连续节拍发生电路。S0 是单步或连续节拍发生控制信号，当 S0&#x3D;0，选择单步运行方式；当 S0&#x3D;1, 选择连续运行方式。【实验数据记录】 本次实验在四节拍的单步&#x2F;连续节拍发生电路基础上，增加节拍数至八位，电路设计图如下：仿真波形图如下：【实验结果分析】图一是本次实验的原理图，节拍脉冲发生器是通过9个D触发器级联实现的，其中T1-T8是脉冲信号，CLK1是时钟信号，RST1是置零信号，S0是控制脉冲是单步还是连续的信号，单步运行只在复位后 T1-T8 依次产生一个脉冲，对应与计算机中执行一条指令，而连续运行复位后 T1-T8 将依次产生脉冲不断循环下去。在波形仿真中可以看到，当RST1低位的时候脉冲信号置零，RST1为高位时脉冲顺序发生，在实验箱中验证，显示了八位的脉冲信号成功生成并可控制。 通过本次实验我理解了节拍脉冲发生器的工作机制，节拍脉冲发生器通过产生节拍信号协调计算机中各个部件之间运作，是计算机中重要的时序控制器件，它能控制发生单步脉冲和连续脉冲，用于控制单步指令的执行还是连续指令程序的运行。 问题回答： 单步运行与连续运行有何区别，它们各自的使用环境怎样？ 单步运行只在复位后 T1-T8 依次产生一个脉冲，而连续运行复位后 T1-T8 将依次产生脉冲不断循环。单步脉冲对应指令的逐条、单步的执行，这种模式允许逐条地观察指令执行的结果和变化，从而进行调试和分析。单步运行特别适用于调试程序中的错误和异常情况，连续脉冲对应指令的连续运行，指程序的执行没有中断，按顺序执行所有的指令直到程序结束或者遇到中断信号。在连续运行模式下，计算机会自动执行指令。 如何实现单步&#x2F;连续运行工作方式的切换？ 增加两个 2-1 多路选择器，单步节拍发生电路改变为单步/连续节拍发生电路。通过输入信号控制单步或连续节拍。 实验四 程序计数器PC与地址寄存器AR实验【实验目的】 掌握地址单元的工作原理。掌握的两种工作方式，加 1 计数和重装计数器初值的实现方法；掌握地址寄存器从程序计数器获得数据和从内部总线获得数据的实现方法。【实验环境】 QuartusII、FPGA实验箱 【实验基本原理及步骤】 实验原理： 地址单元主要由三部分组成：程序计数器、地址寄存器和多路开关。程序计数器 PC 用以指出下一条指令在主存中的存放地址，CPU 正是根据 PC 的内容去存取指令的。因程序中指令是顺序执行的，所以 PC 有自增功能。程序计数器提供下一条程序指令的地址，如电路图 4-2-1 所示，在 T4 时钟脉冲的作用下具有自动加 1 的功能；在 LDPC 信号的作用下可以预置计数器的初值（如子程序调用或中断响应等）。当 LDPC 为高电平时，计数器装入 data[ ]端输入的数据。aclr 是计数器的35清 0 端，高电平有效（高电平清零）；aclr 为低电平时，允许计数器正常计数。地址寄存器 AR（74273）锁存访问内存 SRAM 的地址。273 中的地址来自两个渠道。一是程序计数器 PC 的输出，通常是下一条指令的地址；二是来自于内部数据总线的数据，通常是被访问操作数的地址。为了实现对两路输入数据的切换，在 FPGA 的内部通过总线多路开关 BUSMUX 进行选择。LDAR 与多路选择器的 sel 相连，当 LDAR 为低电平，选择程序计数器的输出；当 LDAR 为高电平时，选择内部数据总线的数据。实验步骤： 按照 图 4-2-1 程序计数器原理图编辑、输入电路，实验台选择 NO.0 工作模式。对输入原理图进行编译、引脚锁定、并下载到实验台。示例工程文件是PC_unit.bdf。硬件实验验证（与仿真波形图 4-2-2 比较！）。实验说明： 下载 pc_unit.sof ； 用模式键选模式“0”，再按一次右侧的复位键； 键 2 和键 1 可输入 8 位总线数据 B7..0；CLR（键 5）按 2 次(0à1à0)，产生一正脉冲，高电平清零；LDAR（键 6）&#x3D;0 时，BUSMUX 输出程序计数器PC 的值；LDAR&#x3D;1 时，BUSMUX 输出 B[7..0]总线数据。LDPC（键 7）：程序计数器 PC 预置控制端，当 LDPC&#x3D;1 时，将 B[7..0]总线数据装入程序计数器PC；当 LDPC&#x3D;0 时，程序计数器 PC 处于计数自动工作状态，对 T4 进行计数；T4（键 8）：程序计数器 PC 的计数时钟 CLK，键 8 按动两次产生一个计数脉冲。 通过 B[7..0]设置程序计数器的预加载数据。当 LDPC&#x3D;0 时，观察程序计数器自动加 1 的功能；当 LDPC&#x3D;1 时，观察程序计数器加载输出情况。 示例操作： 所有键置 0，键 2&#x2F;1 输入 A5；按键 5àPC 计数器清 0(0à1à0)； 连续按动键 8，可以从数码 8&#x2F;7 上看到 AR 的输出，即 PC 值； 按键 6-&gt;’1’，选通直接输出总线上的数据 A5 作为 PC 值，按键 8，产生一个脉冲上升沿，即可看到 AR（显示在数码 8&#x2F;7）的输出为 A5； 使键 6&#x3D;0，仍选通 PC 计数器输出，这时键 2&#x2F;1 输入 86，按键 7 产生一个上升脉冲，即用 LDPC 将 86 加载进 PC 计数器 【实验数据记录】 电路图设计如下：仿真波形如下：【实验结果分析】 本次实验在原有实验基础上将数据从8位增加至12位，并对程序计数器增添自增和自减控制，由updown信号控制，当updown为低电平时，程序计数器自增，updown为高电平时，程序计数器自减。地址寄存器可以从程序计数器获得数据和从内部总线获得数据。LDPC信号用于控制程序计数器初值，LDPC为高电平时将输入的数据存入程序计数器中。为了实现对两路输入数据的切换，在 FPGA 的内部通过总线多路开关lpm_mux进行选择，LDAR 与多路选择器的 sel 相连，当 LDAR 为低电平，选择程序计数器的输出，当 LDAR 为高电平时，选择内部数据总线的数据。这些功能均在波形仿真和实验箱中得到验证。 通过本次实验我理解了计算机中的地址单元，计算机中的地址单元程序计数器 PC 用以指出下一条指令在主存中的存放地址，程序大部分情况是顺序执行的，因此PC通常自增，而在转移、中断或者子程序调用时PC需要加载其他指令的地址，地址寄存器AR用于存放主存地址，访问主存需首先将地址存入AR中，程序计数器、地址寄存器和多路选择组成了计算机中的地址单元，控制访问主存的地址。 问题回答： 分支和转移程序与顺序程序有何区别？要实现程序的分支和转移，需要对程序计数器PC和地址寄存器AR作怎样的操作？应改变哪些控制信号？ 分支和转移程序与顺序程序的主要区别在于执行流程。顺序程序按照预定义的指令序列逐条执行，而分支和转移程序可以根据条件或指令来改变执行流程，跳转到程序的其他部分执行。要实现程序的分支和转移，通常需要对程序计数器（PC）和地址寄存器（AR）进行操作。需要计算转移地址，更新PC的值以指向新的目标地址。在某些情况下，可能还需要更新AR的值以指向正确的内存位置。 实验五 总线控制实验【实验目的】 理解总线的概念及特性；掌握总线传输控制特性。 【实验环境】 QuartusII、FPGA实验箱 【实验基本原理及步骤】 1．总线的基本概念 总线是多个系统部件之间进行数据传输的公共通路，是构成计算机系统的骨架。借助总线连接，计算机在系统各部件之间实现传送地址、数据和控制信息的操作。所谓总线就是指能为多个功能部件服务的一组公用信息线。2．实验原理 实验所用总线实验传输框图如图 5-1 所示。它将几种不同的设备挂在总线上，有存储器、输入设备、输出设备、寄存器。这些设备在传统的系统中需要有三态输出控制，然而在 FPGA 的内部没有三态输出控制结构，因此必须采用总线输出多路开关结构加以控制。按照传输要求恰当有序地控制它们，就可以实现总线信息传输。 实验内容1 根据图5-2完成实验操作：选择实验模式“0”；再按一次右侧的复位键(用一接线将实验板上键9的输入端插针与适配板上FPGA的第P196针相连，以便能用键9控制OUT锁存器的时钟；)：初始状态； 键4、键3控制设备选择端：sel[1..0]&#x3D;00（键4&#x2F;键3&#x3D;00，）； 此时由键2&#x2F;键1输入的数据(26H,显示于数码管2&#x2F;1)直接进入BUS（数码管8&#x2F;7显示），键5、6、7为低电平； 键8&#x3D;1（允许RAM写入）完成图5-2所示的操作： 键5发正脉冲（0-1-0），将数据打入寄存器R0； 键2&#x2F;键1再输入数据(如37H)； 键6发正脉冲（0-1-0），将数据打入地址寄存器AR； 键2&#x2F;键1再输入数据(如48H)； 键7发正脉冲（0-1-0），将数据写入RAM（此时必须键8输出‘1’，注意此时进入RAM的数据48H是放在地址37H单元的）； 键2&#x2F;键1再输入数据(如59H)； 键9发正脉冲（0-1-0），将数据写入寄存器OUT（数码管6&#x2F;5将显示此数）； 键4、键3分别选择sel[1..0]&#x3D;00、01、10、11，从数码管8&#x2F;7上观察被写入的各寄存器中的数据。 实验内容2： 先将数据28H写入RAM的地址（4AH），再将数据1BH送进R0，最后将刚才写入RAM中地址（4AH）的数据读出送到OUT口。依据总线电路图5-3，操作如下： 用一接线将实验板上键9的输入端插针与适配板上FPGA的第P196针相连，以便能用键9控制OUT锁存器的时钟；键3、4、5、6、7、8都为低电平，使键4&#x2F;键3&#x3D;00，即总线多路选择器sel[1..0]&#x3D;00，选择由键2&#x2F;键1输入的数据4AH（地址），直接进入BUS； 按键6两次（0-1-0），产生一个正脉冲，将地址数据4AH（地址）锁入地址寄存器AR，如图5-3所示，此数据直接进入RAM的address端； 按键2&#x2F;键1，输入数据28H（数据），此时直接进入总线BUS，并进入RAM的data数据端；按键8&#x3D;1（RAM写允许）；按键7两次，将数28H写入RAM（地址为4AH），最后按键8&#x3D;0，写禁止，读允许。 由键2&#x2F;键1输入的数据1BH，按键5两次（0-1-0），产生一个正脉冲，即此数写入R0寄存器。 读RAM送到OUT：由键2&#x2F;键1输入的数据4AH，按键5两次，使4AH进入AR； 按键7两次，RAM中4AH单元中的数据28H输出，再使键4&#x2F;键3&#x3D;10，即总线多路选择器sel[1..0]&#x3D;10，此时RAM数据口的28H进入总线BUS（可从数码管8&#x2F;7上看到）； 按键9一次（此键是单脉冲），RAM口的28H即被锁如输出口OUT寄存器，由数码管6&#x2F;5显示。 图5-2 总线数据传输练习操作步骤 键盘&#x2F;显示定义详细说明：1）键2、键1输入D[7..0]，输入的数据同时显示在数码2和数码3上。2）键9、键3输入控制设备选择端sel[1..0]，如图5-2所示，键4&#x2F;键3控制总线多路选择器，选择不同设备的数据进入总线：sel[1..0]&#x3D; 00：输入设备INPUT数据进入总线BUS；&#x3D; 01：寄存器R0中的数据进入总线BUS；&#x3D; 11：地址寄存器AR的数据进入总线BUS；&#x3D; 10：存储器RAM的数据进入总线BUS；4）总线BUS上的输出数据显示在数码8和数码7上；5）键5控制寄存器R0的输入选通锁存端；6）键6控制地址寄存器AR输入选通锁存端；7）键7控制LPM_RAM数据DATA输入锁存端；8）键8控制LPM_RAM写入允许WE端，&#x3D;1有效； 9）键9控制输出设备OUTPUT的输入选通端，输出数据显示在数码6和数码5上，要求首先用一接线将实验板上键9的输入端插针与适配板上FPGA的第P196针相连。 【实验数据记录】 电路图如下：波形仿真如下：【实验结果分析】 在波形仿真中可以看到，LDAR信号高电平时将输入数据存入地址寄存器，这时存入的是90，当s信号为10时，地址寄存器的数据写入总线，可以看到总线的数据为90，与地址寄存器数据一致。当LDR0为高电平时，将输入数据存入寄存器R0中，这时存入的数据是48，当s信号为01时，R0的数据写入总线，可以看到总线的数据为48，与R0的数据一致。本次实验成功经过波形仿真和实验箱验证。 本次实验通过总线与寄存器 R0、AR、RAM 相连，模拟了CPU中的数据通路，实现了输入数据的保存与输出。这次实验让我更加清晰地理解了总线，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。总线是一种内部结构，它是 cpu、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。 问题回答： 如何向 RAM 中输入多个数据，并在输出设备 OUTPUT 上显示这些数据？ 将数据输入到RAM的不同地址中，先输入地址到地址寄存器中，再将数据写入到RAM的数据锁存端中，将数据写入到该地址对应的区域，随后按此步骤再输入多个地址和数据存入RAM，显示数据时，只需要将地址输入到地址寄存器中，读出RAM中对应的数据即可。 传输过程中是否会在总线上发生数据冲突？若发生冲突应怎样避免？ 可能会发生冲突，解决方法： 加入总线仲裁器，每个需要占用总线的设备需发送总线请求信号到仲裁器中，由仲裁器决定哪个设备获得对总线的使用权。","categories":[{"name":"实验","slug":"实验","permalink":"https://wizardtot.github.io/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"实验","slug":"实验","permalink":"https://wizardtot.github.io/tags/%E5%AE%9E%E9%AA%8C/"}],"author":"WizardTOT"},{"title":"Hello World","slug":"hello-world","date":"2024-06-27T11:40:32.268Z","updated":"2024-07-04T03:50:49.760Z","comments":true,"path":"2024/06/27/hello-world/","permalink":"https://wizardtot.github.io/2024/06/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"author":"WizardTOT"}],"categories":[{"name":"实验","slug":"实验","permalink":"https://wizardtot.github.io/categories/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"实验","slug":"实验","permalink":"https://wizardtot.github.io/tags/%E5%AE%9E%E9%AA%8C/"}]}